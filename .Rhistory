distribution = "gaussian")
gb_summary <- summary(train_gb, plotit = FALSE)
gb_highvars <- gb_summary[order(gb_summary$rel.inf,
decreasing = TRUE),] %>% head(5) %>% row.names()
if (length(gb_highvars) < 5) {
add <- 5 - length(gb_highvars)
gb_highvars <- c(gb_highvars, rep("N/A", add))
}
#Test set
yhat.gb <- predict(train_gb, test, n.trees = 1000)
gb_MSE <-
mean((yhat.gb - test$deedlastsaleprice) ^ 2, na.rm = TRUE)
gb_MPE <-
mean((yhat.gb - test$deedlastsaleprice) / test$deedlastsaleprice,
na.rm = TRUE)
gb_MAPE <-
mean(abs((yhat.gb - test$deedlastsaleprice) / test$deedlastsaleprice), na.rm = TRUE)
#Store comparison between rf and gb
if (dta$propertyaddresscity %>% unique() %>% length() == 1) {
subsample_name <-
paste(
dta$situsstatecode %>% unique() %>% as.character() %>% paste(collapse = "_"),
dta$situscounty %>% unique() %>% as.character() %>% paste(collapse = "_"),
dta$propertyaddresscity %>% unique() %>% as.character() %>% paste(collapse = "_"),
sep = "_"
)
} else {
subsample_name <-
paste(
dta$situsstatecode %>% unique() %>% as.character() %>% paste(collapse =
"_"),
dta$situscounty %>% unique() %>% as.character() %>%
paste(collapse = "_")
)
}
comparison <- c(
subsample_name,
preprocess_retention,
nrow(dta),
ncol(dta),
rf_MSE,
rf_MPE,
rf_MAPE,
rf_highvars,
gb_MSE,
gb_MPE,
gb_MAPE,
gb_highvars
) %>% as.data.frame %>% t()
colnames(comparison) <- c(
"subsample",
"preprocess_retention",
"obs",
"vars",
"rf_MSE",
"rf_MPE",
"rf_MAPE",
"rf_1st",
"rf_2nd",
"rf_3rd",
"rf_4th",
"rf_5th",
"gb_MSE",
"gb_MPE",
"gb_MAPE",
"gb_1st",
"gb_2nd",
"gb_3rd",
"gb_4th",
"gb_5th"
)
return(comparison)
}
model.comparison.regularization <-
function(dta, preprocess_retention = retention) {
preprocess_retention <- retention
#Split training/test samples (0.7:0.3)
train <- sample_frac(dta, size = 0.7)
test <- anti_join(dta, train, by = "attomid")
#Prepare y and x features in train
train <- train %>% select(-attomid,-situsstatecode,-situscounty,-propertyaddresscity)
essential.var <- intersect(names(dta),
c(
"deedlastsaledate",
"yearbuilt",
"areabuilding",
"censustract"
)) %>% paste(collapse = "+")
if ("deedlastsaledate" %in% names(dta)) {
formula.1 <- as.formula(
paste(
"deedlastsaleprice~
I(deedlastsaledate^5)+
I(deedlastsaledate^4)+
I(deedlastsaledate^3)+
I(deedlastsaledate^2)+(",
paste(essential.var),
")^2+
(.)"
)
)
} else{
formula.1 <-
as.formula(paste("deedlastsaleprice~(", paste(essential.var), ")^2+(.)"))
}
train <- model.frame(formula.1,
data = train,
na.action = na.omit)
y.train <- train$deedlastsaleprice
x.train <- model.matrix(formula.1,
data = train)
#Prepare test
test <- test %>% select(-attomid,-situsstatecode,-situscounty,-propertyaddresscity)
test <- model.frame(formula.1,
data = test,
na.action = na.omit)
y.test <- test$deedlastsaleprice
x.test <- model.matrix(formula.1,
data = test)
#Predict with Ridge
cv.out <- cv.glmnet(x.train, y.train, alpha = 0)
bestlam <- cv.out$lambda.min
out <-
glmnet(
x.train,
y.train,
nlambda = 1,
lambda = bestlam,
alpha = 0
)
yhat.ridge <- predict(cv.out, s = bestlam, newx <- x.test)
ridge_MSE <- mean((yhat.ridge - y.test) ^ 2, na.rm = TRUE)
ridge_MPE <- mean((yhat.ridge - y.test) / y.test, na.rm = TRUE)
ridge_MAPE <- mean(abs((yhat.ridge - y.test) / y.test), na.rm = TRUE)
#Predict with LASSO
cv.out <- cv.glmnet(x.train, y.train, alpha = 1)
bestlam <- cv.out$lambda.min
out <-
glmnet(
x.train,
y.train,
nlambda = 1,
lambda = bestlam,
alpha = 1
)
yhat.LASSO <- predict(cv.out, s = bestlam, newx <- x.test)
LASSO_MSE <- mean((yhat.LASSO - y.test) ^ 2, na.rm = TRUE)
LASSO_MPE <- mean((yhat.LASSO - y.test) / y.test, na.rm = TRUE)
LASSO_MAPE <- mean(abs((yhat.LASSO - y.test) / y.test), na.rm = TRUE)
#Export important variables
LASSO_coef <-
coef(out) %>% row.names() %>% cbind(coef(out) %>% as.numeric())
LASSO_coef <- LASSO_coef %>% as.data.frame()
names(LASSO_coef) <- c("var", "coef")
LASSO_coef$coef <- LASSO_coef$coef %>% as.character() %>% as.numeric()
LASSO_coef$var <- LASSO_coef$var %>% as.character()
LASSO_coef$abs_coef <- abs(LASSO_coef$coef)
LASSO_coef <-
LASSO_coef[order(LASSO_coef$abs_coef, decreasing = TRUE), ]
LASSO_vars <- LASSO_coef$var[LASSO_coef$coef != 0 &
LASSO_coef$var != "(Intercept)"]
LASSO_length <- LASSO_vars %>% length()
LASSO_names <- LASSO_vars %>% paste(collapse = "  |  ")
#Store comparison between Ridge and LASSO
if (dta$propertyaddresscity %>% unique() %>% length() == 1) {
subsample_name <-
paste(
dta$situsstatecode %>% unique() %>% as.character() %>% paste(collapse =
"_"),
dta$situscounty %>% unique() %>% as.character() %>%
paste(collapse = "_"),
dta$propertyaddresscity %>% unique() %>% as.character() %>%
paste(collapse = "_"),
sep = "_"
)
} else {
subsample_name <-
paste(
dta$situsstatecode %>% unique() %>% as.character() %>% paste(collapse =
"_"),
dta$situscounty %>% unique() %>% as.character() %>%
paste(collapse = "_")
)
}
comparison <- c(
subsample_name,
preprocess_retention,
nrow(dta),
ncol(dta),
ridge_MSE,
ridge_MPE,
ridge_MAPE,
LASSO_MSE,
LASSO_MPE,
LASSO_MAPE,
LASSO_length,
LASSO_names
) %>% as.data.frame %>% t()
colnames(comparison) <- c(
"subsample",
"preprocess_retention",
"obs",
"vars",
"ridge_MSE",
"ridge_MPE",
"ridge_MAPE",
"LASSO_MSE",
"LASSO_MPE",
"LASSO_MAPE",
"LASSO_length",
"LASSO_names"
)
return(comparison)
}
#Assembling the final modeling function combining the previous 2 functions
#The function is applicable to large list.
#Build function to parse modeling output and realize parameter entry
modeling <- function(list,
method = "regularization",
price_h = 5000000,
price_l = 100,
yr_st = 2012,
sz = 1000) {
comparison_set <- NULL
for (i in 1:length(list)) {
dta <- list[[i]]
dta_preprocessed <- model.preprocess(
dta,
price_high = price_h,
price_low = price_l,
start_year = yr_st,
size = sz
)
if (method == "tree") {
comparison <- model.comparison.tree(dta_preprocessed)
}
if (method == "regularization") {
comparison <- model.comparison.regularization(dta_preprocessed)
}
comparison_set <- rbind(comparison_set, comparison)
}
comparison_set <- cbind(
rep(price_h, nrow(comparison_set)),
rep(price_l, nrow(comparison_set)),
rep(yr_st, nrow(comparison_set)),
rep(sz, nrow(comparison_set)),
comparison_set
)
comparison_set <- comparison_set %>% as.data.frame()
names(comparison_set)[1:4] <-
c("price_high", "price_low", "year_start", "size")
comparison_set$preprocess_retention <-
comparison_set$preprocess_retention %>% as.character() %>% as.numeric()
num_vars <- c(
"obs",
"vars",
"rf_MSE",
"rf_MAPE",
"gb_MSE",
"gb_MPE",
"gb_MAPE",
"ridge_MSE",
"ridge_MPE",
"ridge_MAPE",
"LASSO_MSE",
"LASSO_MPE",
"LASSO_MAPE",
"LASSO_length"
)
for (i in names(comparison_set)) {
if (i %in% num_vars) {
comparison_set[[i]] <-
comparison_set[[i]] %>% as.character() %>% as.numeric()
}
}
comparison_set<-comparison_set%>%as.data.frame()
return(comparison_set)
}
load("dta_processed/model_summary.RData")
city_stats <-
home_dta %>% group_by(propertyaddresscity) %>% summarise(
num = n(),
subsample =
str_c(situsstatecode[1],
situscounty[1],
propertyaddresscity[1],
sep = "_"),
price = median(deedlastsaleprice, na.rm = TRUE),
area = median(areabuilding, na.rm = TRUE),
averageprice = median(deedlastsaleprice / areabuilding, na.rm = TRUE),
builtyear = median(yearbuilt, na.rm = TRUE),
dist_coast = mean(dist_coast, na.rm = TRUE),
floodrisk = mean(mdkt32, na.rm = TRUE)
)
major_models <- city_stats %>% inner_join(model_summary, by = "subsample")
major_models$rf_MPE <-
major_models$rf_MPE %>% as.character() %>% as.numeric()
med_floodrisk1 <- median(major_models$floodrisk, na.rm = TRUE)
major_models$floodrisk1 <- NA
major_models$floodrisk1[major_models$floodrisk == 0] <- "no flood risk"
major_models$floodrisk1[major_models$floodrisk > 0 &
major_models$floodrisk <= med_floodrisk1] <-
"low flood risk"
major_models$floodrisk1[major_models$floodrisk > med_floodrisk1] <-
"high flood risk"
#save(major_models,file = "D:/Langyi/graph_data/major_models.RData")
dta<-major_models%>%filter(gb_MAPE<1,rf_MAPE<1)
ggplot(dta)+
geom_point(aes(x=propertyaddresscity[order(dta$rf_MAPE)],
y=rf_MAPE,
color="chartreuse"))+
geom_point(aes(x=propertyaddresscity[order(dta$rf_MAPE)],
y=gb_MAPE,
color="aquamarine2"))+
ggtitle("Random forest mostly outperform gradient boosting",
subtitle = "Showing models with MAPE < 1, gradient boosting in blue") +
xlab("City-level subsamples") +
ylab("MAPE")+
labs(caption = "Source: ATTOM Data Solutions",
fill = "Model") +
theme_classic() +
theme(axis.text.x=element_blank(),
legend.position = "none")
dta<-major_models%>%filter(ridge_MAPE<1,LASSO_MAPE<1)
ggplot(dta)+
geom_point(aes(x=propertyaddresscity[order(dta$rf_MAPE)],
y=LASSO_MAPE,
color="chartreuse"))+
geom_point(aes(x=propertyaddresscity[order(dta$rf_MAPE)],
y=ridge_MAPE,
color="aquamarine2"))+
ggtitle("Ridge and LASSO have similar performance",
subtitle = "Showing models with MAPE < 1, ridge in blue") +
xlab("City-level subsamples") +
ylab("MAPE")+
labs(caption = "Source: ATTOM Data Solutions",
fill = "Model") +
theme_classic() +
theme(axis.text.x=element_blank(),
legend.position = "none")
dta<-major_models%>%filter(ridge_MAPE<1,gb_MAPE<1)
ggplot(dta)+
geom_point(aes(x=propertyaddresscity[order(dta$rf_MAPE)],
y=gb_MAPE,
color="chartreuse"))+
geom_point(aes(x=propertyaddresscity[order(dta$rf_MAPE)],
y=ridge_MAPE,
color="aquamarine2"))+
ggtitle("Disparity exists for comparison of Ridge and GBM performance",
subtitle = "Showing models with MAPE < 1, ridge in blue") +
xlab("City-level subsamples") +
ylab("MAPE")+
labs(caption = "Source: ATTOM Data Solutions",
fill = "Model") +
theme_classic() +
theme(axis.text.x=element_blank(),
legend.position = "none")
major_models%>%select(-LASSO_names)%>%DT::datatable()
ggplot(major_models,
aes(
x = price,
y = floodrisk,
color = floodrisk1,
size = num,
shape = rf_1st
)) +
geom_point() +
geom_jitter() +
scale_size(guide = "none")+
scale_color_brewer(palette = "OrRd",
direction = -1) +
scale_x_continuous(name = "Average property value ($)",
breaks = seq(0, 2000000, by = 200000)) +
scale_y_continuous(name = "Level of flood risk") +
geom_text(
data = major_models%>%filter(rf_MPE < 0.3,
floodrisk > 0.03),
aes(label = propertyaddresscity),
color = "black",
size = 2.5,
hjust = -0.3,
vjust = -0.3
) +
ggtitle("Primary factor of property value in cities",
subtitle = "Cities with high flood risk and high prediction accuracy (within 30%) annotated") +
labs(caption = "Source: ATTOM Data Solutions") +
theme_classic() +
theme(axis.text.x = element_text(angle = 30, hjust = 1))
#Build function to plot series of error for a given tuning parameter
error.plot <- function(dta = error_matrix,
title = "Parameter values") {
retention <- ggplot(data = dta) +
geom_line(aes(x = Parameter*100,
y = Retention),
color = "tomato4") +
xlab(title) +
ylab("% of obs kept") +
theme(legend.position = "left") +
theme_classic()
mse <- ggplot(data = dta) +
geom_line(aes(x = Parameter,
y = MSE),
color = "tomato4") +
xlab(title) +
ylab("MSE") +
theme(legend.position = "left") +
theme_classic()
mpe <- ggplot(data = dta) +
geom_line(aes(x = Parameter*100,
y = MPE),
color = "tomato4") +
xlab(title) +
ylab("MPE %") +
theme(legend.position = "left") +
theme_classic()
mape <- ggplot(data = dta) +
geom_line(aes(x = Parameter*100,
y = MAPE),
color = "tomato4") +
xlab(title) +
ylab("MAPE %") +
theme(legend.position = "left") +
theme_classic()
grid.arrange(retention, mse, mape, mpe)
}
load("dta_processed/sz.RData")
error.plot(error_matrix, "Maximum sample size")
load("dta_processed/price_l.RData")
error.plot(error_matrix, "Lowest price of property to be included")
load("dta_processed/yr_st.RData")
error.plot(error_matrix, "Oldest property record to be included")
load("dta_processed/price_h.RData")
error.plot(error_matrix, "Highest price of property to be included")
load("dta_processed/regularization_rf_set_city.RData")
rf_set_city[order(rf_set_city$LASSO_MAPE),]%>%select(-LASSO_names)%>%DT::datatable()
load("dta_processed/regularization_rf_set_county.RData")
rf_set_county[order(rf_set_county$LASSO_MAPE),]%>%select(-LASSO_names)%>%DT::datatable()
#merge model performance data by county to parcel file
rf_set_county1 <- rf_set_county
rf_set_county1$subsample <-
rf_set_county1$subsample %>% str_sub(start = 4L)
names(rf_set_county1)[5] <- "NAME"
parcel@data <- inner_join(parcel@data, rf_set_county1, by = "NAME")
tmap_arrange(
summary.county(varname = "preprocess_retention"),
summary.county(varname = "obs"),
summary.county(varname = "vars"),
summary.county(varname = "LASSO_MSE"),
summary.county(varname = "LASSO_MPE"),
summary.county(varname = "LASSO_MAPE"),
ncol = 3
)
names(major_models)
major_models%>%select(subsample,
averageprice%>%round(2),
floodrisk%>%round(2),
rf_MAPE%>%round(2),
gb_MAPE%>%round(2),
ridge_MAPE%>%round(2),
LASSO_MAPE%>%round(2))%>%DT::datatable()
major_models%>%select(subsample,
averageprice,
floodrisk,
rf_MAPE,
gb_MAPE,
ridge_MAPE,
LASSO_MAPE)%>%DT::datatable()
## 7 Visualize model performance
```{r,fig.width=20}
major_models%>%select(subsample,
averageprice,
floodrisk,
rf_MAPE,
gb_MAPE,
ridge_MAPE,
LASSO_MAPE)%>%DT::datatable()
major_models%>%select(subsample,
averageprice,
floodrisk,
rf_MAPE,
gb_MAPE,
ridge_MAPE,
LASSO_MAPE)%>%DT::datatable()
load("dta_processed/regularization_rf_set_city.RData")
rf_set_city[order(rf_set_city$LASSO_MAPE), ] %>% select(subsample,
averageprice,
floodrisk,
rf_MAPE,
gb_MAPE,
ridge_MAPE,
LASSO_MAPE) %>% DT::datatable()
rf_set_city%>%names()
load("dta_processed/regularization_rf_set_city.RData")
rf_set_city[order(rf_set_city$LASSO_MAPE), ] %>% select(subsample,
floodrisk,
rf_MAPE,
gb_MAPE,
ridge_MAPE,
LASSO_MAPE) %>% DT::datatable()
load("dta_processed/regularization_rf_set_city.RData")
rf_set_city[order(rf_set_city$LASSO_MAPE), ] %>% select(subsample,
rf_MAPE,
gb_MAPE,
ridge_MAPE,
LASSO_MAPE) %>% DT::datatable()
load("dta_processed/regularization_rf_set_city.RData")
rf_set_city[order(rf_set_city$LASSO_MAPE), ] %>% select(subsample,
ridge_MPE,
ridge_MAPE,
LASSO_MPE,
LASSO_MAPE) %>% DT::datatable()
unlink('slides_cache', recursive = TRUE)
